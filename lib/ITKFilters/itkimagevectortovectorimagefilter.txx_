#ifndef ITKIMAGEVECTORTOVECTORIMAGEFILTER_TXX
#define ITKIMAGEVECTORTOVECTORIMAGEFILTER_TXX


using namespace std;


namespace itk {

template< class TInputImageVector,class TInputImage >
ImageVectorToVectorImageFilter<TInputImageVector, TInputImage>::ImageVectorToVectorImageFilter()
{
    m_imagevector = 0;
}

template< class TInputImageVector,class TInputImage >
void ImageVectorToVectorImageFilter<TInputImageVector, TInputImage>::GenerateOutputInformation(void){
    // Override the method in itkImageSource, so we can set the vector length of
    // the output itk::VectorImage

    if(this->m_imagevector == 0){
        itkExceptionMacro(<< "Input rgbImage not set!");
    }


    typedef itk::ImageRegionIterator< InputImageVectorype >    IteratorVectorType;
    typedef itk::ImageRegionIterator< InputImageType >    IteratorType;

    IteratorVectorType vectIt(this->m_imagevector,this->m_imagevector->GetLargestPossibleRegion() );

    vectIt.GoToBegin();

    if(!vectIt.IsAtEnd()){
        for(unsigned i = 0; i < vectIt.Get().Size(); i++){

            typename InputImageType::Pointer imagecolor = InputImageType::New();
            imagecolor->SetRegions(this->m_imagevector->GetLargestPossibleRegion());
            imagecolor->Allocate();
            IteratorType  imageIt(  imagecolor, imagecolor->GetLargestPossibleRegion() );

            imageIt.GoToBegin();
            vectIt.GoToBegin();

            while( !imageIt.IsAtEnd() )
            {

               imageIt.Set(vectIt.Get()[i]);

                ++imageIt;
                ++vectIt;
            }

            this->Superclass::SetInput(i, imagecolor);

        }
    }
    this->Superclass::GenerateOutputInformation();

}

template< class TInputImageVector,class TInputImage >
void ImageVectorToVectorImageFilter< TInputImageVector, TInputImage > ::SetInput(const InputImageVectorype *input){
    m_imagevector = (InputImageVectorype*) input;
}


}//itk namespace

#endif
