#ifndef OPTIMIZATIONTEXTURE_TXX
#define OPTIMIZATIONTEXTURE_TXX


#include <itkVectorResampleImageFilter.h>
#include <itkAffineTransform.h>
#include <itkVectorLinearInterpolateImageFunction.h>

#include <itkShrinkImageFilter.h>
#include <itkVectorExpandImageFilter.h>

#include <itkResampleImageFilter.h>

#include <itkImageSliceConstIteratorWithIndex.h>

namespace itk{

template <class TInputImage>
OptimizationTexture <TInputImage>::OptimizationTexture()
{
    m_InputImageObject = 0;
    m_StepNumber = 1;
    m_TexelDimension = 3;
    m_R = 0.8;
    m_LevelOptimization = 3;
}


template <class TInputImage>
void OptimizationTexture <TInputImage>::GenerateData(){    

    InputImagePointer imagesample = const_cast< InputImageType * >(this->GetInput());
    InputImagePointer imageobject = this->m_InputImageObject;

    if(!imagesample){
        itkExceptionMacro(<< "Input sample not set!");
    }

    if(!imageobject){
        itkExceptionMacro(<< "Input imageobject not set!");
    }

    if(m_StepNumber < 1){
        itkExceptionMacro(<< "The step number has to be greater than 1");
    }



    /*typedef itk::VectorResampleImageFilter<InputImageType,InputImageType> ResampleFilterType;
    typedef itk::AffineTransform< double, 2 >  TransformType;
    typename TransformType::Pointer transform = TransformType::New();
    typedef itk::VectorLinearInterpolateImageFunction< InputImageType > VectorLinearInterpolateType;
    typename VectorLinearInterpolateType::Pointer vectorinterpolate = VectorLinearInterpolateType::New();
    typename InputImageType::PixelType defaultpixel;
    defaultpixel[0] = 255;
    defaultpixel[1] = 255;
    defaultpixel[2] = 255;
    typename InputImageType::SizeType   size;

    typename ResampleFilterType::Pointer resampleobject = ResampleFilterType::New();
    resampleobject->SetTransform( transform );
    resampleobject->SetInterpolator( vectorinterpolate );
    resampleobject->SetDefaultPixelValue( defaultpixel );
    resampleobject->SetOutputSpacing(imageobject->GetSpacing());
    resampleobject->SetOutputOrigin(imageobject->GetOrigin());
    size = imageobject->GetRequestedRegion().GetSize();
    size[0] /= 8;
    size[1] /= 8;
    resampleobject->SetSize( size );
    resampleobject->SetInput(imageobject);
    resampleobject->Update();
    InputImagePointer imageobjectdown = resampleobject->GetOutput();*/






    /*OutputImageType* imageoutput = this->GetOutput();
    imageoutput->SetRegions(imageobjectdown->GetRequestedRegion());
    imageoutput->Allocate();*/







    typedef itk::ShrinkImageFilter< InputImageType, InputImageType > ShrinkFilterType;
    typename ShrinkFilterType::Pointer shrinkfilter = ShrinkFilterType::New();    
    shrinkfilter->SetShrinkFactors(8);
    shrinkfilter->SetInput(imageobject);
    shrinkfilter->Update();
    //InputImagePointer imageobjectdown = shrinkfilter->GetOutput();
    InputImagePointer imageobjectdown = imageobject;



    setupANN(imagesample);
    searchPhase(imageobjectdown);


    typedef itk::ImageFileWriter< InputImageType > ImageWriterType;
    typename ImageWriterType::Pointer map_writer = ImageWriterType::New();




    for(unsigned i = 0; i < 3; i++){
        for(unsigned j = 0; j < 10; j++){


            std::string filename = "testOptimization";
            char buffer[10];
            sprintf(buffer, "%d-%d", i, j);
            filename.append( buffer );
            filename.append(".png");
            map_writer->SetFileName(filename.c_str());
            map_writer->SetInput( imageobjectdown );
            map_writer->Update();

            optimizationPhase(imageobjectdown);
            imageobjectdown = this->GetOutput();
            searchPhase(imageobjectdown);


        }

        typedef itk::VectorExpandImageFilter< InputImageType, InputImageType > VectorExpandImageType;
        typename VectorExpandImageType::Pointer vectorexpandimage = VectorExpandImageType::New();
        vectorexpandimage->SetExpandFactors(2);
        vectorexpandimage->SetInput(imageobjectdown);
        vectorexpandimage->Update();
        imageobjectdown = vectorexpandimage->GetOutput();
        searchPhase(imageobjectdown);


    }



}

template <class TInputImage>
void OptimizationTexture <TInputImage>::setupANN(InputImagePointer imagesample){

    typename ImageFeaturesType::Pointer imagefeatures = ImageFeaturesType::New();
    imagefeatures->DebugOn();
    imagefeatures->SetNeighborhoodSize(m_NeighborhoodSize);
    imagefeatures->SetInput(imagesample);
    imagefeatures->Update();

    m_ColorSample = const_cast<ListSampleType*>(imagefeatures->GetListSample());

    m_PCAReduction = PCAReductionType::New();
    //pcareduction->DebugOn();
    m_PCAReduction->SetKeepValues(0.95);
    m_PCAReduction->SetInputSample(m_ColorSample);
    m_PCAReduction->Update();
    ListSampleType *pcasampleout = m_PCAReduction->GetOutput();

    this->m_ANNConnector = SampleANNConnectorType::New();
    m_ANNConnector->SetInputSample(pcasampleout);
    m_ANNConnector->Update();
}

template <class TInputImage>
double OptimizationTexture <TInputImage>::getImageEnergy(TexturesVectorsType Sv, TexturesVectorsType Ev){

    unsigned int objectindex = 0;

    for(unsigned i = 0; i < m_Sv.size(); i++){
        for(unsigned j = 0; j < m_Sv[i].size(); j++){


            for(unsigned k = 0; k < m_Sv[i][j].GetSize(); k++){
                Sv[i][j][k] - Ev[i][j][k];
            }
        }
    }
    return 0;
}


template <class TInputImage>
void OptimizationTexture <TInputImage>::optimizationPhase(InputImagePointer imageobject){


    OutputImageType* imageoutput = this->GetOutput();
    imageoutput->SetRegions(imageobject->GetRequestedRegion());
    imageoutput->Allocate();

    unsigned int imagedim = imageobject->GetLargestPossibleRegion().GetImageDimension();
    double *texelval = new double[m_TexelDimension];

    typedef itk::NeighborhoodIterator< InputImageType > NeighborhoodIteratorType;
    typename NeighborhoodIteratorType::RadiusType radius;
    radius.Fill(m_NeighborhoodSize/2);

    NeighborhoodIteratorType objectit(radius, imageobject, imageobject->GetRequestedRegion());
    objectit.GoToBegin();

    NeighborhoodIteratorType outputit(radius, imageoutput, imageoutput->GetRequestedRegion());
    outputit.GoToBegin();

    unsigned int objectindex = 0;
    while(!objectit.IsAtEnd()){

        if(objectit.InBounds()){            

            //when all the neighborhoods arround the current pixel in the object are found
            //is time to use the ANN library to found the closest neighbour
            //note that the current vector goes through the PCA analysis to reduce its dimmensionality
            //the dimension should be equal to the points in the ANN space to perform the search stage

            double sumw_vi = 0;

            for(unsigned i = 0; i < m_TexelDimension; i++) texelval[i] = 0;

            for(unsigned i = 0; i < m_Sv[objectindex].size(); i++){ //note that m_Sv contains texel values for the three perpendicular dimensions
                                                                    //m_Sv[objectindex] = all texel values
                                                                    //m_Sv[objectindex][i] = perpendicular slice to x, y, z and m_Sv[objectindex][i][j] are the actual texel values



                double w_vi = 0;

                /*for(unsigned j = 0; j < m_Sv[objectindex][i].GetSize(); j+=m_TexelDimension){ //starting from a position j then for all the values of the texel
                    for(unsigned k = 0; k < m_TexelDimension; k++){
                        double temps_vi = m_Sv[objectindex][i][j+k];
                        double tempe_vi = m_Ev[objectindex][i][j+k];
                        w_vi += pow(temps_vi - tempe_vi, 2);//calculating the distance between the two texels (value_object_v,i,u - value_texel_v,i,u) = s_v,i,u - e_v,i,u
                    }
                    w_vi = sqrt( w_vi ); //distance calculation
                    //the result of the norm is then w_vi ^ (r-2) (r = 0.8)
                    w_vi = pow( w_vi, m_R - 2);
                    w_vi = 1;

                    for(unsigned k = 0; k < m_TexelDimension; k++){
                        texelval[k] += w_vi *  m_Ev[objectindex][i][j+k]; // the values of the current texel are multiplied by w_vi and added to
                                                      //variable that contains the final value of the texel
                    }

                    sumw_vi +=  w_vi;                      //the current value of w_vi is added (denominator of the equation)
                }*/
                for(unsigned j = 0; j < m_Sv[objectindex][i].GetSize(); j++){ //starting from a position j then for all the values of the texel

                    double temps_vi = m_Sv[objectindex][i][j];
                    double tempe_vi = m_Ev[objectindex][i][j];
                    w_vi += pow(temps_vi - tempe_vi, 2);//calculating the distance between the two texels (value_object_v,i,u - value_texel_v,i,u) = s_v,i,u - e_v,i,u
                }

                w_vi = sqrt( w_vi ); //distance calculation
                //the result of the norm is then w_vi ^ (r-2) (r = 0.8)
                w_vi = pow( w_vi, m_R - 2);

                for(unsigned j = 0; j < m_Sv[objectindex][i].GetSize(); j+=m_TexelDimension){
                    for(unsigned k = 0; k < m_TexelDimension; k++){
                        texelval[k] += w_vi *  m_Ev[objectindex][i][j+k]; // the values of the current texel are multiplied by w_vi and added to
                                                      //variable that contains the final value of the texel
                    }

                    sumw_vi +=  w_vi;                      //the current value of w_vi is added (denominator of the equation)
                }

            }

            OutputImagePixelType texel;

            for(unsigned i = 0; i < m_TexelDimension; i++){
                texelval[i] /= sumw_vi;
                if(texelval[i] < 0 || texelval[i] > 255){
                    cout<<"ff"<<endl;
                }
                texel[i] = (unsigned char) ((texelval[i]));
            }
            //cout<<"texel "<<(int)texel[0]<<" "<<(int)texel[1]<<" "<<(int)texel[2]<<endl;
            //cout<<"texelval "<<texelval[0]<<" "<<texelval[1]<<" "<<texelval[2]<<endl;
            //objectit.SetCenterPixel(texel);
            outputit.SetCenterPixel(texel);
            objectindex++;
        }else{
            OutputImagePixelType texel;
            texel[0] = 0;
            texel[1] = 0;
            texel[2] = 0;
            outputit.SetCenterPixel(texel);
        }

        ++objectit;
        ++outputit;
    }


    delete texelval;
}

template <class TInputImage>
void OptimizationTexture <TInputImage>::searchPhase(InputImagePointer imageobject){




    typedef itk::ImageSliceConstIteratorWithIndex< InputImageType > SliceIteratorType;
    SliceIteratorType sliceit(imageobject, imageobject->GetRequestedRegion());

    unsigned int firstdir = 0;
    unsigned int secondir = 1;
    unsigned int imagedim = imageobject->GetLargestPossibleRegion().GetImageDimension();

    sliceit.SetFirstDirection(firstdir);
    sliceit.SetSecondDirection(secondir);
    sliceit.GoToBegin();

    unsigned int neighborhoodsize = m_NeighborhoodSize/2;

    typedef itk::NeighborhoodIterator< InputImageType > NeighborhoodIteratorType;
    typename NeighborhoodIteratorType::RadiusType radius;
    radius.Fill(neighborhoodsize);
    NeighborhoodIteratorType objectit(radius, imageobject, imageobject->GetRequestedRegion());
    objectit.GoToBegin();


    m_Ev.clear();
    m_Sv.clear();

    while(!sliceit.IsAtEnd()){

        while( !sliceit.IsAtEndOfSlice() ){

            bool moveline = false;

            while( !sliceit.IsAtEndOfLine() ){


                objectit.SetLocation(sliceit.GetIndex());
                //Creating the vectors s_vi with the corresponding neighborhoods in the object image
                vector< typename PCAReductionType::MeasurementVectorType > s_vi;

                if(objectit.InBounds()){

                    moveline = true;

                    if(imagedim == 2){
                        typename PCAReductionType::MeasurementVectorType s_vxyz;
                        s_vxyz.SetSize(m_ColorSample->GetMeasurementVectorSize());
                        s_vxyz.Fill(-1);
                        s_vi.push_back(s_vxyz);

                    }else if(imagedim == 3){
                        for(unsigned i = 0; i < imagedim; i++){
                            typename PCAReductionType::MeasurementVectorType s_vxyz;
                            s_vxyz.SetSize(m_ColorSample->GetMeasurementVectorSize());
                            s_vxyz.Fill(-1);
                            s_vi.push_back(s_vxyz);
                        }
                    }

                    unsigned positionvector = 0;


                    for (unsigned i = 0; i < objectit.Size(); i++){
                        if (imagedim == 2){
                            for(unsigned j = 0; j < m_TexelDimension; j++){
                                s_vi[0].SetElement(positionvector+j, objectit.GetPixel(i)[j]);
                            }
                            positionvector+= m_TexelDimension;
                        }
                    }

                    vector< typename PCAReductionType::MeasurementVectorType > e_vi;

                    for(unsigned i = 0; i < s_vi.size();i++){
                        typename PCAReductionType::MeasurementVectorType reducedvector;
                        reducedvector = m_PCAReduction->GetPCAReduceVector(s_vi[i]);//for each vector PCA reduce dimension is used
                        m_ANNConnector->Evaluate(reducedvector);
                        int indexsample = m_ANNConnector->GetNearestNeighbours()[0];//the closest neighbour is found
                        itkDebugMacro(<<" "<<indexsample<<" ");

                        //original texture vector
                        typename PCAReductionType::MeasurementVectorType closesttexture;

                        closesttexture = m_ColorSample->GetMeasurementVector(indexsample);//the vector that contains the actual values in the texture sample
                                                                              // note that the index corresponds to the original vector in the sample feature space
                        e_vi.push_back(closesttexture);

                    }

                    m_Sv.push_back(s_vi);
                    m_Ev.push_back(e_vi);




                    for(unsigned i = 0; i < m_NeighborhoodSize-1 && !sliceit.IsAtEndOfLine();i++){
                        ++sliceit;
                    }



                }else{
                    ++sliceit;
                }
            }
            if(moveline){
                for(unsigned i = 0; i < m_NeighborhoodSize-1 && !sliceit.IsAtEndOfSlice();i++){
                    sliceit.NextLine();
                }
            }else{
                sliceit.NextLine();
            }
        }
        sliceit.NextSlice();
    }

}




}//namespace itk

#endif
