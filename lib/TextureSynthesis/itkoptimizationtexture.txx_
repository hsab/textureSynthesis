#ifndef OPTIMIZATIONTEXTURE_TXX
#define OPTIMIZATIONTEXTURE_TXX


#include <itkVectorResampleImageFilter.h>
#include <itkAffineTransform.h>
#include <itkVectorLinearInterpolateImageFunction.h>

#include <itkShrinkImageFilter.h>
#include <itkVectorExpandImageFilter.h>

#include <itkResampleImageFilter.h>

namespace itk{

template <class TInputImage>
OptimizationTexture <TInputImage>::OptimizationTexture()
{
    m_InputImageObject = 0;
    m_StepNumber = 1;
    m_TexelDimension = 3;
    m_R = 0.8;
    m_LevelOptimization = 3;
}


template <class TInputImage>
void OptimizationTexture <TInputImage>::GenerateData(){    

    InputImagePointer imagesample = const_cast< InputImageType * >(this->GetInput());
    InputImagePointer imageobject = this->m_InputImageObject;

    if(!imagesample){
        itkExceptionMacro(<< "Input sample not set!");
    }

    if(!imageobject){
        itkExceptionMacro(<< "Input imageobject not set!");
    }

    if(m_StepNumber < 1){
        itkExceptionMacro(<< "The step number has to be greater than 1");
    }



    /*typedef itk::VectorResampleImageFilter<InputImageType,InputImageType> ResampleFilterType;
    typedef itk::AffineTransform< double, 2 >  TransformType;
    typename TransformType::Pointer transform = TransformType::New();
    typedef itk::VectorLinearInterpolateImageFunction< InputImageType > VectorLinearInterpolateType;
    typename VectorLinearInterpolateType::Pointer vectorinterpolate = VectorLinearInterpolateType::New();
    typename InputImageType::PixelType defaultpixel;
    defaultpixel[0] = 255;
    defaultpixel[1] = 255;
    defaultpixel[2] = 255;
    typename InputImageType::SizeType   size;

    typename ResampleFilterType::Pointer resampleobject = ResampleFilterType::New();
    resampleobject->SetTransform( transform );
    resampleobject->SetInterpolator( vectorinterpolate );
    resampleobject->SetDefaultPixelValue( defaultpixel );
    resampleobject->SetOutputSpacing(imageobject->GetSpacing());
    resampleobject->SetOutputOrigin(imageobject->GetOrigin());
    size = imageobject->GetRequestedRegion().GetSize();
    size[0] /= 8;
    size[1] /= 8;
    resampleobject->SetSize( size );
    resampleobject->SetInput(imageobject);
    resampleobject->Update();
    InputImagePointer imageobjectdown = resampleobject->GetOutput();*/






    /*OutputImageType* imageoutput = this->GetOutput();
    imageoutput->SetRegions(imageobjectdown->GetRequestedRegion());
    imageoutput->Allocate();*/



    setupANN(imagesample);



    typedef itk::ShrinkImageFilter< InputImageType, InputImageType > ShrinkFilterType;
    typename ShrinkFilterType::Pointer shrinkfilter = ShrinkFilterType::New();
    shrinkfilter->SetShrinkFactors(8);
    shrinkfilter->SetInput(imageobject);
    shrinkfilter->Update();
    InputImagePointer imageobjectdown = shrinkfilter->GetOutput();


    typedef itk::ImageFileWriter< InputImageType > ImageWriterType;
    typename ImageWriterType::Pointer map_writer = ImageWriterType::New();


    for(unsigned i = 0; i < 3; i++){


        optimizationPhase(imageobjectdown);
        imageobjectdown = this->GetOutput();
        //searchPhase(imageobjectdown);


        typedef itk::VectorExpandImageFilter< InputImageType, InputImageType > VectorExpandImageType;
        typename VectorExpandImageType::Pointer vectorexpandimage = VectorExpandImageType::New();
        vectorexpandimage->SetExpandFactors(2);
        vectorexpandimage->SetInput(imageobjectdown);
        vectorexpandimage->Update();
        imageobjectdown = vectorexpandimage->GetOutput();





        std::string filename = "testOptimization";
        char buffer[10];
        sprintf(buffer, "%d", i);
        filename.append( buffer );
        filename.append(".png");
        map_writer->SetFileName(filename.c_str());
        map_writer->SetInput( imageobjectdown );
        map_writer->Update();



    }

}

template <class TInputImage>
void OptimizationTexture <TInputImage>::setupANN(InputImagePointer imagesample){

    typename ImageFeaturesType::Pointer imagefeatures = ImageFeaturesType::New();
    imagefeatures->DebugOn();
    imagefeatures->SetNeighborhoodSize(m_NeighborhoodSize);
    imagefeatures->SetInput(imagesample);
    imagefeatures->Update();

    m_ColorSample = const_cast<ListSampleType*>(imagefeatures->GetListSample());

    m_PCAReduction = PCAReductionType::New();
    //pcareduction->DebugOn();
    m_PCAReduction->SetKeepValues(0.95);
    m_PCAReduction->SetInputSample(m_ColorSample);
    m_PCAReduction->Update();
    ListSampleType *pcasampleout = m_PCAReduction->GetOutput();

    this->m_ANNConnector = SampleANNConnectorType::New();
    m_ANNConnector->SetInputSample(pcasampleout);
    m_ANNConnector->Update();
}


template <class TInputImage>
void OptimizationTexture <TInputImage>::optimizationPhase(InputImagePointer imageobject){


    OutputImageType* imageoutput = this->GetOutput();
    imageoutput->SetRegions(imageobject->GetRequestedRegion());
    imageoutput->Allocate();

    unsigned int imagedim = imageobject->GetLargestPossibleRegion().GetImageDimension();
    double *texelval = new double[m_TexelDimension];

    typedef itk::NeighborhoodIterator< InputImageType > NeighborhoodIteratorType;
    typename NeighborhoodIteratorType::RadiusType radius;
    radius.Fill(m_NeighborhoodSize/2);

    NeighborhoodIteratorType objectit(radius, imageobject, imageobject->GetRequestedRegion());
    objectit.GoToBegin();

    NeighborhoodIteratorType outputit(radius, imageoutput, imageoutput->GetRequestedRegion());
    outputit.GoToBegin();

    while(!objectit.IsAtEnd()){

        if(objectit.InBounds()){

            //Creating the vectors s_vi with the corresponding neighborhoods in the object image
            vector< typename PCAReductionType::MeasurementVectorType > s_vi;

            //typename InputImageType::IndexType cornerindex = objectit.GetIndex(objectit.Size()-1);

            for(unsigned j = 0; j < imagedim; j++){
                for(unsigned k = j+1; k < imagedim; k++){

                    typename PCAReductionType::MeasurementVectorType currentvector;
                    currentvector.SetSize(m_ColorSample->GetMeasurementVectorSize());
                    currentvector.Fill(-1);

                    int fixdim = -1;
                    for(unsigned i = 0; i < imagedim; i++){
                        if(i != j && i != k){
                            fixdim = i;
                        }
                    }

                    unsigned positionvector = 0;

                    for (unsigned i = 0; i < objectit.Size(); i++)
                    {
                        bool valfixdim = true;
                        if(fixdim != -1){
                            //get the center texel index and compare against the current object value on the fixed dimension
                            //note that only the plances with the center texel are going to be considered
                            valfixdim = objectit.GetIndex()[fixdim] == objectit.GetIndex(i)[fixdim];
                        }

                        if(valfixdim){
                            for(unsigned j = 0; j < m_TexelDimension; j++){

                                currentvector.SetElement(positionvector+j, objectit.GetPixel(i)[j]);
                            }
                            positionvector+= m_TexelDimension;
                        }
                    }

                    s_vi.push_back(currentvector);
                }
            }

            //when all the neighborhoods arround the current pixel in the object are found
            //is time to use the ANN library to found the closest neighbour
            //note that the current vector goes through the PCA analysis to reduce its dimmensionality
            //the dimension should be equal to the points in the ANN space to perform the search stage

            double sumw_vi = 0;

            for(unsigned i = 0; i < m_TexelDimension; i++) texelval[i] = 0;

            for(unsigned i = 0; i < s_vi.size();i++){
                typename PCAReductionType::MeasurementVectorType reducedvector;
                reducedvector = m_PCAReduction->GetPCAReduceVector(s_vi[i]);//for each vector PCA reduce dimension is used
                m_ANNConnector->Evaluate(reducedvector);
                int indexsample = m_ANNConnector->GetNearestNeighbours()[0];//the closest neighbour is found
                itkDebugMacro(<<" "<<indexsample<<" ");

                //original texture vector
                typename PCAReductionType::MeasurementVectorType e_vi;
                e_vi = m_ColorSample->GetMeasurementVector(indexsample);//the vector that contains the actual values in the texture sample
                                                                      // note that the index corresponds to the original vector in the sample feature space

                //for each n dimensional texel in the neighborhood found that contains the closest neighborhood, calculate w_vi

                for(unsigned j = 0; j < e_vi.GetSize(); j+= m_TexelDimension){ //note that e_vi contains the values of all texels in the neighborhood
                    double w_vi = 0;

                    for(unsigned k = 0; k < m_TexelDimension; k++){ //starting from a position j then for all the values of the texel
                        double temps_vi = s_vi[i][j + k];
                        double tempe_vi = e_vi[j + k];
                        w_vi += pow(temps_vi - tempe_vi, 2);//calculating the norm (value_object_v,i,u - value_texel_v,i,u) = s_v,i,u - e_v,i,u
                    }
                    w_vi = sqrt( w_vi ); //norm calculation
                    //the result of the norm is then w_vi ^ (r-2) (r = 0.8)
                    w_vi = pow( w_vi, m_R - 2);
                    //w_vi = 0.02;
                    for(unsigned k = 0; k < m_TexelDimension; k++){
                        texelval[k] += w_vi * e_vi[j + k]; // the values of the current texel are multiplied by w_vi and added to
                                                      //variable that contains the final value of the texel
                    }

                    sumw_vi +=  w_vi;                      //the current value of w_vi is added (denominator of the equation)
                }

            }

            OutputImagePixelType texel;
            for(unsigned i = 0; i < m_TexelDimension; i++){
                texelval[i] /= sumw_vi;
                if(texelval[i] < 0 || texelval[i] > 255){
                    cout<<"ff"<<endl;
                }
                texel[i] = (unsigned char) ((texelval[i]));
            }
            //cout<<"texel "<<(int)texel[0]<<" "<<(int)texel[1]<<" "<<(int)texel[2]<<endl;
            //cout<<"texelval "<<texelval[0]<<" "<<texelval[1]<<" "<<texelval[2]<<endl;
            objectit.SetCenterPixel(texel);
            outputit.SetCenterPixel(texel);

        }

        ++objectit;
        ++outputit;
    }


    delete texelval;
}

template <class TInputImage>
void OptimizationTexture <TInputImage>::searchPhase(InputImagePointer imageobject){

    //OutputImageType* imageoutput = this->GetOutput();

    unsigned int imagedim = imageobject->GetLargestPossibleRegion().GetImageDimension();
    double *texelval = new double[m_TexelDimension];

    typedef itk::NeighborhoodIterator< InputImageType > NeighborhoodIteratorType;
    typename NeighborhoodIteratorType::RadiusType radius2;
    radius2.Fill(m_NeighborhoodSize/2);

    NeighborhoodIteratorType objectit(radius2, imageobject, imageobject->GetRequestedRegion());
    objectit.GoToBegin();

    typename NeighborhoodIteratorType::RadiusType radius4;
    radius4.Fill(m_NeighborhoodSize/4);

    NeighborhoodIteratorType objectitR4(radius4, imageobject, imageobject->GetRequestedRegion());
    objectitR4.GoToBegin();

    while(!objectit.IsAtEnd()){

        if(objectit.InBounds() && objectitR4.InBounds()){


            for(unsigned j = 0; j < imagedim; j++){
                for(unsigned k = j+1; k < imagedim; k++){

                    typename PCAReductionType::MeasurementVectorType currentvector;
                    currentvector.SetSize(m_ColorSample->GetMeasurementVectorSize());
                    currentvector.Fill(-1);

                    int fixdim = -1;
                    for(unsigned i = 0; i < imagedim; i++){
                        if(i != j && i != k){
                            fixdim = i;
                        }
                    }

                    unsigned positionvector = 0;

                    for (unsigned i = 0; i < objectit.Size(); i++)
                    {
                        bool valfixdim = true;
                        if(fixdim != -1){
                            //get the center texel index and compare against the current object value on the fixed dimension
                            //note that only the plances with the center texel are going to be considered
                            valfixdim = objectit.GetIndex()[fixdim] == objectit.GetIndex(i)[fixdim];
                        }

                        if(valfixdim){
                            for(unsigned j = 0; j < m_TexelDimension; j++){

                                currentvector.SetElement(positionvector+j, objectit.GetPixel(i)[j]);
                            }
                            positionvector+= m_TexelDimension;
                        }
                    }

                    typename PCAReductionType::MeasurementVectorType reducedvector;
                    reducedvector = m_PCAReduction->GetPCAReduceVector(currentvector);

                    m_ANNConnector->Evaluate(reducedvector);
                    int indexsample = m_ANNConnector->GetNearestNeighbours()[0];
                    itkDebugMacro(<<" "<<indexsample<<" ");


                    typename PCAReductionType::MeasurementVectorType e_vi;
                    e_vi = m_ColorSample->GetMeasurementVector(indexsample);
                    unsigned positione_vi = 0;

                    for (unsigned i = 0; i < objectit.Size(); i++)
                    {
                        bool valfixdim = true;
                        if(fixdim != -1){
                            //get the center texel index and compare against the current object value on the fixed dimension
                            //note that only the plances with the center texel are going to be considered
                            valfixdim = objectit.GetIndex()[fixdim] == objectit.GetIndex(i)[fixdim];
                        }

                        if(valfixdim){

                            for(unsigned l = 0; l < objectitR4.Size(); l++ ){
                                if(objectitR4.GetIndex(l) == objectit.GetIndex(i)){
                                    OutputImagePixelType texel;
                                    for(unsigned m = 0; m < m_TexelDimension; m++){
                                        texel[m] = (unsigned char) ((e_vi[positione_vi + m]));
                                    }
                                    objectitR4.SetPixel(l, texel);
                                }
                            }
                            positione_vi += m_TexelDimension;
                        }
                    }
                }
            }


            //cout<<"texel "<<(int)texel[0]<<" "<<(int)texel[1]<<" "<<(int)texel[2]<<endl;
        }

        ++objectit;
        ++objectitR4;
        //++outputit;
    }


    delete texelval;

}

}//namespace itk

#endif
